以前我们写并发的程序一般是用多线程来实现，自己维护一个线程池，在恰当的时候创建、销毁、分配资源。

`go` 在并发方面为我们提供了一个语言级别的支持， `goroutine` 和 `chan` 相互配合，这决定了他的先天优势。

`goroutine` 的概念类似于线程， `Go` 程序运行时会自动调度和管理，系统能智能地将 `goroutine` 中的任务合理地分配给 `CPU` , 让这些任务尽量并发运作。

#### 他和线程对比

**从使用上讲**

* 比线程更轻量级，可以创建十万、百万不用担心资源问题。
* 和 `chan` 搭配使用，实现高并发， `goroutine` 之间传输数据更方便。
* 如果访问同一个数据块，要小心数据竞态问题、共享锁还是互斥锁的选择问题、并发操作的数据同步问题（后面会说）

**从其实现上讲**

* 从资源上讲，线程的栈内存大小一般是固定的一般为 `2MB` ，虽然这个数值可以设置，但是 太大了浪费，太小了容易不够用, 而 `goroutine` 栈内存是可变的，初始一般为 `2KB` ，随着需求可以扩大达到1GB。 所以 `goroutine` 十分的轻量级，且能满足不同的需求。
* 从调度上讲，线程的调度由 `OS` 的内核完成；线程的切换需要 **CPU寄存器** 和 **内存的数据交换** ，从而切换不同的线程上下文。 其触发方式为 `CPU时钟` , 而 `goroutine` 的调度则比较轻量级，由自身的调度器完成。
* 协程同线程的关系，有些类似于 线程同进程的关系。

#### 创建与使用

创建一个 `goroutine` ，只需要在函数前加一个 `go` 关键字就成了。

``` Go
go 函数名(参数)
```

看一个 `dome` 

``` Go
func quickFun(){
	fmt.Println("maybe you can's see me!")
}

func main(){
	go quickFun() // 创建了一个 goroutine
	fmt.Println("hey")
	time.Sleep(time.Second)
}
```

* `goroutine` 和 `main` 主线程同时运行
* `main` 运行结束会暴力终止所有协程，所以上面的程序多等待了1秒
* `Go` 程序从 `main` 包的 `main()` 函数开始，在程序启动时， `Go` 程序就会为 `main()` 函数创建一个默认的 `goroutine` 。

输出

``` 
hey
maybe you can's see me!
```

对，就是这么简单，如果你的函数只在这里使用，也可以用匿名函数来创建 `goroutine` 。

``` Go
func main(){
	go func() {
		fmt.Println("hello ")
	}()
	time.Sleep(time.Second) //main运行结束会暴力终止所有协程，所以这里先等待1秒
}
```

PS: 和线程不同，`goroutine`没有唯一的`id`，所以我们没办法专门正对某个协程进行操作。

#### 
